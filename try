modules/product/_test_/product.controller.spec.ts
  ‚óè Test suite failed to run

    src/utils/logger/logger-config.ts:11:35 - error TS1343: The 'import.meta' meta-property is only allowed when the '--module' option is 'es2020', 'es2022', 'esnext', 'system', 'node16', 'node18', or 'nodenext'.

    11 const requireFunc = createRequire(import.meta.url);

getting error while running test cases
following is my tsconfig.json
"""
{
  "compilerOptions": {
    "target": "ES2020",                                /* Set to ES2020 for modern JavaScript features. */
    "module": "ESNext",                                /* Use ESNext for modern modules. */
    "useDefineForClassFields": true,                   /* Use defined class fields. */
    "lib": ["ES2020", "DOM", "DOM.Iterable"],          /* Update to ES2020 libraries, DOM is optional if not used. */
    "moduleResolution": "node",                        /* Resolve modules in node fashion. */
    "skipLibCheck": true,                              /* Skip type checking of .d.ts files. */
    "esModuleInterop": true,                           /* Enable interoperability with commonjs modules. */
    // "forceConsistentCasingInFileNames": true,          /* Ensure consistent casing in imports. */
    "allowSyntheticDefaultImports": true,              /* Allow default imports from modules that do not have them. */
    "resolveJsonModule": true,                         /* Allow importing JSON files. */
    "isolatedModules": true,                           /* Improve build speed for isolated files. */
    "strict": false,                                    /* Enable all strict type-checking options. */
    "noUnusedLocals": true,                            /* Report errors on unused locals. */
    "noUnusedParameters": true,                        /* Report errors on unused parameters. */
    "noFallthroughCasesInSwitch": true,                /* Disallow fallthrough cases in switch statements. */
    "outDir": "./dist",                                /* Output directory for compiled files. */
    "allowJs": true,                                   /* Allow JS files to be compiled. */
    // "noEmit": false,                             /* Enable emitting compiled files. */
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"],
  "ts-node": {
    "esm": true // Enable ESM in ts-node
  }
}

"""
following is my jest.config.cjs
"""
module.exports = {
  testMatch: [
    '**/tests/**/*.+(ts|tsx)',
    '**/?(*.)+(spec|test).+(ts|tsx)',
  ],
  transform: {
    '^.+\\.(ts|tsx)$': [
      'ts-jest',
      {
        useESM: true
      }
    ]
    
  },
  
  preset: 'ts-jest',
  moduleNameMapper: {
    "^(\\.\\.?\\/.+)\\.js$": "$1",
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json'],
  rootDir: "src",
  setupFiles: ['<rootDir>/jest/setEnvVars.js'],
};
"""
follwoing is my package.json
"""
{
  "name": "sip-api",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "build": "npx tsc",
    "start": "node --loader ts-node/esm src/server.ts",
    "dev": "nodemon src/server.ts",
    "ci-build": "npx tsc",
    "test": "cross-env NODE_OPTIONS=--experimental-vm-modules npx jest --coverage",
    "coverage": "cross-env NODE_OPTIONS=--experimental-vm-modules npx jest --coverage",
    "lint": "eslint . --ignore-pattern dist/",
    "test:e2e": "echo Your script goes here to test e2e"
  },
  "type": "module",
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@eslint/js": "^9.14.0",
    "@types/apicache": "^1.6.6",
    "@types/compression": "^1.7.5",
    "@types/cookie-parser": "^1.4.7",
    "@types/cors": "^2.8.17",
    "@types/crypto-js": "^4.2.2",
    "@types/express": "^4.17.13",
    "@types/express-rate-limit": "^6.0.2",
    "@types/helmet": "^4.0.0",
    "@types/jsonwebtoken": "^9.0.7",
    "@types/morgan": "^1.9.9",
    "@types/node": "^18.11.12",
    "@types/nodemailer": "^6.4.16",
    "@types/swagger-ui-express": "^4.1.7",
    "eslint": "^9.14.0",
    "eslint-plugin-react": "^7.37.2",
    "globals": "^15.12.0",
    "nodemon": "^3.1.9",
    "typescript": "^5.6.3"
  },
  "dependencies": {
    "@aws-sdk/client-lambda": "^3.691.0",
    "@aws-sdk/client-s3": "^3.693.0",
    "@aws-sdk/client-sfn": "^3.691.0",
    "@types/debug": "^4.1.12",
    "@types/jest": "^29.5.14",
    "apicache": "^1.6.3",
    "app-root-path": "^3.1.0",
    "axios": "^1.7.7",
    "clean-deep": "^3.4.0",
    "cls-rtracer": "^2.6.3",
    "compression": "^1.7.5",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "cross-env": "^7.0.3",
    "crypto-js": "^4.2.0",
    "dotenv": "^16.4.5",
    "eslint": "^9.12.0",
    "express": "^4.21.1",
    "express-rate-limit": "^7.4.1",
    "globals": "^15.10.0",
    "helmet": "^7.2.0",
    "http-status": "^1.8.1",
    "jest": "^29.7.0",
    "json-diff": "^1.0.6",
    "json-mask": "^2.0.0",
    "jsonschema": "^1.4.1",
    "jsonwebtoken": "^9.0.2",
    "jspdf": "^3.0.0",
    "jspdf-autotable": "^5.0.2",
    "kafkajs": "^2.2.4",
    "mockingoose": "^2.16.2",
    "mongodb": "^6.10.0000",
    "mongoose": "^8.8.1",
    "morgan": "^1.10.0",
    "node-cron": "^3.0.3",
    "nodemailer": "^6.9.16",
    "oracledb": "^6.7.0",
    "p-limit": "^6.1.0",
    "pg": "^8.13.3",
    "pino": "^9.5.0",
    "qs": "^6.13.0",
    "sequelize": "^6.37.5",
    "swagger-ui-express": "^5.0.1",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript-eslint": "^8.14.000",
    "unset-value": "^2.0.1",
    "winston": "^3.17.0"
  }
}
"""
following is my logger-config.ts
"""

import rTracer from 'cls-rtracer';
import { createLogger, format, transports } from 'winston';
import path from 'path';
import fs from 'fs';
import { createRequire } from 'module';

const { combine, timestamp, printf, json, label } = format;

// Resolve __dirname for ES modules
const requireFunc = createRequire(import.meta.url);
const __filename = requireFunc.resolve("");
const __dirname = path.dirname(__filename);

// Define the log file directory
const LOG_DIR = path.join(__dirname, '../../logs');

// Ensure the logs directory exists
if (!fs.existsSync(LOG_DIR)) {
  fs.mkdirSync(LOG_DIR, { recursive: true });
}

// Get the current date in YYYY-MM-DD format
const getLogFileName = () => {
  const currentDate = new Date().toISOString().split('T')[0]; // Format: YYYY-MM-DD
  return path.join(LOG_DIR, `${currentDate}.log`);
};

// Log level configuration
const LOGLEVEL = process.env.LOG_LEVEL || 'http';

const loggerConfig = {
  levels: {
    error: 0,
    warn: 1,
    info: 2,
    http: 3,
    verbose: 4,
    debug: 5,
    silly: 6,
  },
};

const logLevels = Object.keys(loggerConfig.levels);

// Correlation ID format
const rTracerFormat = printf((info) => {
  const rid = rTracer.id();
  const logInfo = { ...info, correlationId: rid };
  return JSON.stringify(logInfo);
});

// File transport for logging into date-wise log files
const fileTransport = new transports.File({
  filename: getLogFileName(), // Dynamic filename based on date
  level: 'http', // Minimum log level for file
  format: combine(
    label({ label: process.env.npm_package_name || 'App' }),
    timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    json(), // Store log messages as JSON
    printf(({ timestamp, level, message, label, ...meta }) => {
      return `[${timestamp}] [${label}] [${level.toUpperCase()}] ${message} ${JSON.stringify(
        meta
      )}`;
    })
  ),
});

// Create the logger
const logger = createLogger({
  levels: loggerConfig.levels,
  level: LOGLEVEL && logLevels.includes(LOGLEVEL?.toLowerCase()) ? LOGLEVEL.toLowerCase() : 'http',
  transports: [
    new transports.Console({
      format: format.combine(
        format.label({ label: process.env.npm_package_name }),
        format.timestamp(),
        format.json(),
        rTracerFormat
      ),
    }),
    fileTransport,
  ],
});

// Export the logger and rTracer
export { rTracer, logger };
"""
following is my product-controller.spec.ts
"""
import { mockRequest, mockResponse } from "../../../utils/MockInterceptor.js";
import { ProductMock } from "../../../mocks/Product.mock.js";
import ProductModel, { initializeProductModel } from "../product.model.js";
import initializeProductController from "../product.controller.js";

const mockedProductModel = ProductModel  as jest.Mock;
const mockedinitializeProductModel = initializeProductModel as jest.Mock;

jest.mock("p-limit", () => {
  return 12;
});
jest.mock("../product.model");
jest.mock("../../calculation_api/calculation.model");
jest.mock("../../formula/formula.model");
jest.mock("../../raw_material_search/rm_search.model");

describe("initializeProductController", () => {
  const res = mockResponse();
  const req = mockRequest();
  const next = jest.fn();
  res.locals = {
    user: {
      unique_name: "ITEST123",
      name: "ITEST123",
    },
  };
  req.query = {
    skip: 1,
    sortOrder: -1,
    type: "experiment",
  };
  req.params = {
    id: "66f3b5d7d17ef901390cc805",
    assessmentType: "experimental",
    searchString: "test",
  };
  req.body = {
    shortBrandCode: "JJB",
    formula_number: "TAB2299983A-002",
    type: "baseline",
    name: "Poonam",
    role: "Member",
    mail: "PKadam04@kenvue.com",
    assessmentType: "baseline",
    productId: "66f2930877a89aa14b990958",
    ...ProductMock[0].assessments.baseline,
  };
  req.header["x-consumer-userId"] = "ITEST236";

  it("Should route to pagination for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.pagination(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to myProductPagination for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.myProductPagination(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to create for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.create(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to findById for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.findById(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to findByIdAndUpdate for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.findByIdAndUpdate(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to findByIdAndDelete for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.findByIdAndDelete(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to createAssessment for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.createAssessment(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to createAssessment for failure message", async () => {
    mockedProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue([]),
    });
    mockedinitializeProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue([]),
    });
    const productController = await initializeProductController();
    await productController.createAssessment(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
  });

  it("Should route to updateAssessmentById for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.updateAssessmentById(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to updateAssessmentById for failure message", async () => {
    mockedProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue([]),
    });
    mockedinitializeProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue([]),
    });
    const productController = await initializeProductController();
    await productController.updateAssessmentById(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
  });

  it("Should route to updateAssessmentById for failure message", async () => {
    mockedProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue(ProductMock),
    });
    mockedinitializeProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue(ProductMock),
    });
    req.body = {
      ...req.body,
      assessmentId: "test",
    };
    const productController = await initializeProductController();
    await productController.updateAssessmentById(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
  });

  it("Should route to deleteAssessmentById for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.deleteAssessmentById(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to deleteAssessmentById for failure message", async () => {
    mockedProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue([]),
    });
    mockedinitializeProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue([]),
    });
    const productController = await initializeProductController();
    await productController.deleteAssessmentById(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
  });

  it("Should route to deleteAssessmentById for failure message", async () => {
    mockedProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue(ProductMock),
    });
    mockedinitializeProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue(ProductMock),
    });
    req.body = {
      ...req.body,
      assessmentId: "test",
    };
    const productController = await initializeProductController();
    await productController.deleteAssessmentById(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
  });

  it("Should route to addTeamMember for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.addTeamMember(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({
      message: "Incorrect Product Id",
    });
  });

  it("Should route to updateMemberById for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.updateMemberById(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({
      message: "Incorrect Product Id",
    });
  });

  it("Should route to deleteMemberById for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.deleteMemberById(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({
      message: "Incorrect Product Id",
    });
  });

  it("Should route to addEditPackagingDetails for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.addEditPackagingDetails(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({
      message: "Incorrect Product Id",
    });
  });

  it("Should route to experimentalAssessmentDetails for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.experimentalAssessmentDetails(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({
      message: "Incorrect Product Id",
    });
  });

  it("Should route to addUpdateFormulationDetails for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.addUpdateFormulationDetails(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({
      message: "Incorrect Product Id",
    });
  });
});
"""
how to tackle this error and run the test file successfully?
