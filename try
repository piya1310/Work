{
  "compilerOptions": {
    "target": "ES2020",                                /* Set to ES2020 for modern JavaScript features. */
    "module": "ESNext",                                /* Use ESNext for modern modules. */
    "useDefineForClassFields": true,                   /* Use defined class fields. */
    "lib": ["ES2020", "DOM", "DOM.Iterable"],          /* Update to ES2020 libraries, DOM is optional if not used. */
    "moduleResolution": "node",                        /* Resolve modules in node fashion. */
    "skipLibCheck": true,                              /* Skip type checking of .d.ts files. */
    "esModuleInterop": true,                           /* Enable interoperability with commonjs modules. */
    // "forceConsistentCasingInFileNames": true,          /* Ensure consistent casing in imports. */
    "allowSyntheticDefaultImports": true,              /* Allow default imports from modules that do not have them. */
    "resolveJsonModule": true,                         /* Allow importing JSON files. */
    "isolatedModules": true,                           /* Improve build speed for isolated files. */
    "strict": false,                                    /* Enable all strict type-checking options. */
    "noUnusedLocals": true,                            /* Report errors on unused locals. */
    "noUnusedParameters": true,                        /* Report errors on unused parameters. */
    "noFallthroughCasesInSwitch": true,                /* Disallow fallthrough cases in switch statements. */
    "outDir": "./dist",                                /* Output directory for compiled files. */
    "allowJs": true,                                   /* Allow JS files to be compiled. */
    // "noEmit": false,                             /* Enable emitting compiled files. */
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"],
  "ts-node": {
    "esm": true // Enable ESM in ts-node
  }
}
above is my tsconfig.js
following is my logger-config.ts
"""
{
  "compilerOptions": {
    "target": "ES2020",                                /* Set to ES2020 for modern JavaScript features. */
    "module": "ESNext",                                /* Use ESNext for modern modules. */
    "useDefineForClassFields": true,                   /* Use defined class fields. */
    "lib": ["ES2020", "DOM", "DOM.Iterable"],          /* Update to ES2020 libraries, DOM is optional if not used. */
    "moduleResolution": "node",                        /* Resolve modules in node fashion. */
    "skipLibCheck": true,                              /* Skip type checking of .d.ts files. */
    "esModuleInterop": true,                           /* Enable interoperability with commonjs modules. */
    // "forceConsistentCasingInFileNames": true,          /* Ensure consistent casing in imports. */
    "allowSyntheticDefaultImports": true,              /* Allow default imports from modules that do not have them. */
    "resolveJsonModule": true,                         /* Allow importing JSON files. */
    "isolatedModules": true,                           /* Improve build speed for isolated files. */
    "strict": false,                                    /* Enable all strict type-checking options. */
    "noUnusedLocals": true,                            /* Report errors on unused locals. */
    "noUnusedParameters": true,                        /* Report errors on unused parameters. */
    "noFallthroughCasesInSwitch": true,                /* Disallow fallthrough cases in switch statements. */
    "outDir": "./dist",                                /* Output directory for compiled files. */
    "allowJs": true,                                   /* Allow JS files to be compiled. */
    // "noEmit": false,                             /* Enable emitting compiled files. */
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"],
  "ts-node": {
    "esm": true // Enable ESM in ts-node
  }
}

"""
following is my product.controller.spec.ts file
"""
import { mockRequest, mockResponse } from "../../../utils/MockInterceptor.js";
import { ProductMock } from "../../../mocks/Product.mock.js";
import ProductModel, { initializeProductModel } from "../product.model.js";
import initializeProductController from "../product.controller.js";

const mockedProductModel = ProductModel  as jest.Mock;
const mockedinitializeProductModel = initializeProductModel as jest.Mock;

jest.mock("p-limit", () => {
  return 12;
});
jest.mock("../product.model");
jest.mock("../../calculation_api/calculation.model");
jest.mock("../../formula/formula.model");
jest.mock("../../raw_material_search/rm_search.model");

describe("initializeProductController", () => {
  const res = mockResponse();
  const req = mockRequest();
  const next = jest.fn();
  res.locals = {
    user: {
      unique_name: "ITEST123",
      name: "ITEST123",
    },
  };
  req.query = {
    skip: 1,
    sortOrder: -1,
    type: "experiment",
  };
  req.params = {
    id: "66f3b5d7d17ef901390cc805",
    assessmentType: "experimental",
    searchString: "test",
  };
  req.body = {
    shortBrandCode: "JJB",
    formula_number: "TAB2299983A-002",
    type: "baseline",
    name: "Poonam",
    role: "Member",
    mail: "PKadam04@kenvue.com",
    assessmentType: "baseline",
    productId: "66f2930877a89aa14b990958",
    ...ProductMock[0].assessments.baseline,
  };
  req.header["x-consumer-userId"] = "ITEST236";

  it("Should route to pagination for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.pagination(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to myProductPagination for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.myProductPagination(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to create for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.create(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to findById for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.findById(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to findByIdAndUpdate for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.findByIdAndUpdate(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to findByIdAndDelete for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.findByIdAndDelete(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to createAssessment for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.createAssessment(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to createAssessment for failure message", async () => {
    mockedProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue([]),
    });
    mockedinitializeProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue([]),
    });
    const productController = await initializeProductController();
    await productController.createAssessment(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
  });

  it("Should route to updateAssessmentById for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.updateAssessmentById(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to updateAssessmentById for failure message", async () => {
    mockedProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue([]),
    });
    mockedinitializeProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue([]),
    });
    const productController = await initializeProductController();
    await productController.updateAssessmentById(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
  });

  it("Should route to updateAssessmentById for failure message", async () => {
    mockedProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue(ProductMock),
    });
    mockedinitializeProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue(ProductMock),
    });
    req.body = {
      ...req.body,
      assessmentId: "test",
    };
    const productController = await initializeProductController();
    await productController.updateAssessmentById(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
  });

  it("Should route to deleteAssessmentById for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.deleteAssessmentById(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to deleteAssessmentById for failure message", async () => {
    mockedProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue([]),
    });
    mockedinitializeProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue([]),
    });
    const productController = await initializeProductController();
    await productController.deleteAssessmentById(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
  });

  it("Should route to deleteAssessmentById for failure message", async () => {
    mockedProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue(ProductMock),
    });
    mockedinitializeProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue(ProductMock),
    });
    req.body = {
      ...req.body,
      assessmentId: "test",
    };
    const productController = await initializeProductController();
    await productController.deleteAssessmentById(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
  });

  it("Should route to addTeamMember for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.addTeamMember(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({
      message: "Incorrect Product Id",
    });
  });

  it("Should route to updateMemberById for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.updateMemberById(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({
      message: "Incorrect Product Id",
    });
  });

  it("Should route to deleteMemberById for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.deleteMemberById(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({
      message: "Incorrect Product Id",
    });
  });

  it("Should route to addEditPackagingDetails for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.addEditPackagingDetails(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({
      message: "Incorrect Product Id",
    });
  });

  it("Should route to experimentalAssessmentDetails for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.experimentalAssessmentDetails(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({
      message: "Incorrect Product Id",
    });
  });

  it("Should route to addUpdateFormulationDetails for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.addUpdateFormulationDetails(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({
      message: "Incorrect Product Id",
    });
  });
});

"""
following is my test error 
 FAIL  modules/product/_test_/product.controller.spec.ts
  ‚óè Test suite failed to run

    src/utils/logger/logger-config.ts:11:7 - error TS2441: Duplicate identifier 'require'. Compiler reserves name 'require' in top level scope of a module.

    11 const require = createRequire(import.meta.url);
             ~~~~~~~
    src/utils/logger/logger-config.ts:11:31 - error TS1343: The 'import.meta' meta-property is only allowed when the '--module' option is 'es2020', 'es2022', 'esnext', 'system', 'node16', 'node18', or 'nodenext'.

    11 const require = createRequire(import.meta.url);
