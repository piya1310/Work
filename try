 FAIL  modules/product/_test_/product.controller.spec.ts
  ● Test suite failed to run

    src/utils/logger/logger-config.ts:11:7 - error TS2441: Duplicate identifier 'require'. Compiler reserves name 'require' in top level scope of a module.

    11 const require = createRequire(import.meta.url);
             ~~~~~~~
    src/utils/logger/logger-config.ts:11:31 - error TS1343: The 'import.meta' meta-property is only allowed when the '--module' option is 'es2020', 'es2022', 'esnext', 'system', 'node16', 'node18', or 'nodenext'.

    11 const require = createRequire(import.meta.url);
                                     ~~~~~~~~~~~

 FAIL  modules/product/_test_/product.routes.spec.ts
  ● Test suite failed to run

    src/utils/logger/logger-config.ts:11:7 - error TS2441: Duplicate identifier 'require'. Compiler reserves name 'require' in top level scope of a module.

    11 const require = createRequire(import.meta.url);
             ~~~~~~~
    src/utils/logger/logger-config.ts:11:31 - error TS1343: The 'import.meta' meta-property is only allowed when the '--module' option is 'es2020', 'es2022', 'esnext', 'system', 'node16', 'node18', or 'nodenext'.

    11 const require = createRequire(import.meta.url);
                                     ~~~~~~~~~~~

 FAIL  modules/raw_material_search/_test_/rm_search.controller.spec.ts (31.71 s)
  ● RawMaterialSearchController › should return a list of raw material codes based on initialValue query

    Failed to connect to database: MongooseServerSelectionError: Could not connect to any servers in your MongoDB Atlas cluster. One common reason is that you're trying to access the database from an IP that isn't whitelisted. Make sure your current IP address is on your Atlas cluster's IP whitelist: https://www.mongodb.com/docs/atlas/security-whitelist/ - DB URI mongodb://SIP-Dev-SystemAccount:pass@sip-dev-pl-0.eovja.mongodb.net/sip?connectTimeoutMS=15000&retryWrites=true&w=majority

    

      at connectDatabase (lib/db.connection.ts:675:11)
i am getting above changes after changing the logger-config.ts
"""
// Required imports
import rTracer from 'cls-rtracer';
import { createLogger, format, transports } from 'winston';
import path from 'path';
import fs from 'fs';
import { createRequire } from 'module';

const { combine, timestamp, printf, json, label } = format;

// Resolve __dirname for ES modules
const require = createRequire(import.meta.url);
const __filename = require.resolve("");
const __dirname = path.dirname(__filename);

// Define the log file directory
const LOG_DIR = path.join(__dirname, '../../logs');

// Ensure the logs directory exists
if (!fs.existsSync(LOG_DIR)) {
  fs.mkdirSync(LOG_DIR, { recursive: true });
}

// Get the current date in YYYY-MM-DD format
const getLogFileName = () => {
  const currentDate = new Date().toISOString().split('T')[0]; // Format: YYYY-MM-DD
  return path.join(LOG_DIR, `${currentDate}.log`);
};

// Log level configuration
const LOGLEVEL = process.env.LOG_LEVEL || 'http';

const loggerConfig = {
  levels: {
    error: 0,
    warn: 1,
    info: 2,
    http: 3,
    verbose: 4,
    debug: 5,
    silly: 6,
  },
};

const logLevels = Object.keys(loggerConfig.levels);

// Correlation ID format
const rTracerFormat = printf((info) => {
  const rid = rTracer.id();
  const logInfo = { ...info, correlationId: rid };
  return JSON.stringify(logInfo);
});

// File transport for logging into date-wise log files
const fileTransport = new transports.File({
  filename: getLogFileName(), // Dynamic filename based on date
  level: 'http', // Minimum log level for file
  format: combine(
    label({ label: process.env.npm_package_name || 'App' }),
    timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    json(), // Store log messages as JSON
    printf(({ timestamp, level, message, label, ...meta }) => {
      return `[${timestamp}] [${label}] [${level.toUpperCase()}] ${message} ${JSON.stringify(
        meta
      )}`;
    })
  ),
});

// Create the logger
const logger = createLogger({
  levels: loggerConfig.levels,
  level: LOGLEVEL && logLevels.includes(LOGLEVEL?.toLowerCase()) ? LOGLEVEL.toLowerCase() : 'http',
  transports: [
    new transports.Console({
      format: format.combine(
        format.label({ label: process.env.npm_package_name }),
        format.timestamp(),
        format.json(),
        rTracerFormat
      ),
    }),
    fileTransport,
  ],
});

// Export the logger and rTracer
export { rTracer, logger };
"""
following is my modules/product/_test_/product.controller.spec.ts
"""
import { mockRequest, mockResponse } from "../../../utils/MockInterceptor.js";
import { ProductMock } from "../../../mocks/Product.mock.js";
import ProductModel, { initializeProductModel } from "../product.model.js";
import initializeProductController from "../product.controller.js";

const mockedProductModel = ProductModel  as jest.Mock;
const mockedinitializeProductModel = initializeProductModel as jest.Mock;

jest.mock("p-limit", () => {
  return 12;
});
jest.mock("../product.model");
jest.mock("../../calculation_api/calculation.model");
jest.mock("../../formula/formula.model");
jest.mock("../../raw_material_search/rm_search.model");

describe("initializeProductController", () => {
  const res = mockResponse();
  const req = mockRequest();
  const next = jest.fn();
  res.locals = {
    user: {
      unique_name: "ITEST123",
      name: "ITEST123",
    },
  };
  req.query = {
    skip: 1,
    sortOrder: -1,
    type: "experiment",
  };
  req.params = {
    id: "66f3b5d7d17ef901390cc805",
    assessmentType: "experimental",
    searchString: "test",
  };
  req.body = {
    shortBrandCode: "JJB",
    formula_number: "TAB2299983A-002",
    type: "baseline",
    name: "Poonam",
    role: "Member",
    mail: "PKadam04@kenvue.com",
    assessmentType: "baseline",
    productId: "66f2930877a89aa14b990958",
    ...ProductMock[0].assessments.baseline,
  };
  req.header["x-consumer-userId"] = "ITEST236";

  it("Should route to pagination for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.pagination(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to myProductPagination for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.myProductPagination(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to create for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.create(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to findById for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.findById(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to findByIdAndUpdate for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.findByIdAndUpdate(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to findByIdAndDelete for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.findByIdAndDelete(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to createAssessment for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.createAssessment(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to createAssessment for failure message", async () => {
    mockedProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue([]),
    });
    mockedinitializeProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue([]),
    });
    const productController = await initializeProductController();
    await productController.createAssessment(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
  });

  it("Should route to updateAssessmentById for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.updateAssessmentById(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to updateAssessmentById for failure message", async () => {
    mockedProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue([]),
    });
    mockedinitializeProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue([]),
    });
    const productController = await initializeProductController();
    await productController.updateAssessmentById(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
  });

  it("Should route to updateAssessmentById for failure message", async () => {
    mockedProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue(ProductMock),
    });
    mockedinitializeProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue(ProductMock),
    });
    req.body = {
      ...req.body,
      assessmentId: "test",
    };
    const productController = await initializeProductController();
    await productController.updateAssessmentById(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
  });

  it("Should route to deleteAssessmentById for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.deleteAssessmentById(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  it("Should route to deleteAssessmentById for failure message", async () => {
    mockedProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue([]),
    });
    mockedinitializeProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue([]),
    });
    const productController = await initializeProductController();
    await productController.deleteAssessmentById(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
  });

  it("Should route to deleteAssessmentById for failure message", async () => {
    mockedProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue(ProductMock),
    });
    mockedinitializeProductModel.mockReturnValue({
      aggregate: jest.fn().mockReturnThis(),
      findOne: jest.fn().mockReturnThis(),
      sort: jest.fn().mockReturnValue(ProductMock[0]),
      find: jest.fn().mockReturnValue(ProductMock),
      create: jest.fn().mockReturnValue(ProductMock),
      findByIdAndUpdate: jest.fn().mockReturnValue(ProductMock),
      findOneAndUpdate: jest.fn().mockReturnValue(ProductMock),
      exec: jest
        .fn()
        .mockResolvedValue([{ skip: "test" }])
        .mockReturnValue(ProductMock),
    });
    req.body = {
      ...req.body,
      assessmentId: "test",
    };
    const productController = await initializeProductController();
    await productController.deleteAssessmentById(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
  });

  it("Should route to addTeamMember for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.addTeamMember(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({
      message: "Incorrect Product Id",
    });
  });

  it("Should route to updateMemberById for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.updateMemberById(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({
      message: "Incorrect Product Id",
    });
  });

  it("Should route to deleteMemberById for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.deleteMemberById(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({
      message: "Incorrect Product Id",
    });
  });

  it("Should route to addEditPackagingDetails for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.addEditPackagingDetails(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({
      message: "Incorrect Product Id",
    });
  });

  it("Should route to experimentalAssessmentDetails for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.experimentalAssessmentDetails(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({
      message: "Incorrect Product Id",
    });
  });

  it("Should route to addUpdateFormulationDetails for failure message", async () => {
    mockedProductModel.mockReturnValue({});
    mockedinitializeProductModel.mockReturnValue({});
    const productController = await initializeProductController();
    await productController.addUpdateFormulationDetails(req, res, next);
    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({
      message: "Incorrect Product Id",
    });
  });
});

"""
following is my package.json
"""
{
  "name": "sip-api",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "build": "npx tsc",
    "start": "node --loader ts-node/esm src/server.ts",
    "dev": "nodemon src/server.ts",
    "ci-build": "npx tsc",
    "test": "cross-env NODE_OPTIONS=--experimental-vm-modules npx jest --coverage",
    "coverage": "cross-env NODE_OPTIONS=--experimental-vm-modules npx jest --coverage",
    "lint": "eslint . --ignore-pattern dist/",
    "test:e2e": "echo Your script goes here to test e2e"
  },
  "type": "module",
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@eslint/js": "^9.14.0",
    "@types/apicache": "^1.6.6",
    "@types/compression": "^1.7.5",
    "@types/cookie-parser": "^1.4.7",
    "@types/cors": "^2.8.17",
    "@types/crypto-js": "^4.2.2",
    "@types/express": "^4.17.13",
    "@types/express-rate-limit": "^6.0.2",
    "@types/helmet": "^4.0.0",
    "@types/jsonwebtoken": "^9.0.7",
    "@types/morgan": "^1.9.9",
    "@types/node": "^18.11.12",
    "@types/nodemailer": "^6.4.16",
    "@types/swagger-ui-express": "^4.1.7",
    "eslint": "^9.14.0",
    "eslint-plugin-react": "^7.37.2",
    "globals": "^15.12.0",
    "nodemon": "^3.1.9",
    "typescript": "^5.6.3"
  },
  "dependencies": {
    "@aws-sdk/client-lambda": "^3.691.0",
    "@aws-sdk/client-s3": "^3.693.0",
    "@aws-sdk/client-sfn": "^3.691.0",
    "@types/debug": "^4.1.12",
    "@types/jest": "^29.5.14",
    "apicache": "^1.6.3",
    "app-root-path": "^3.1.0",
    "axios": "^1.7.7",
    "clean-deep": "^3.4.0",
    "cls-rtracer": "^2.6.3",
    "compression": "^1.7.5",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "cross-env": "^7.0.3",
    "crypto-js": "^4.2.0",
    "dotenv": "^16.4.5",
    "eslint": "^9.12.0",
    "express": "^4.21.1",
    "express-rate-limit": "^7.4.1",
    "globals": "^15.10.0",
    "helmet": "^7.2.0",
    "http-status": "^1.8.1",
    "jest": "^29.7.0",
    "json-diff": "^1.0.6",
    "json-mask": "^2.0.0",
    "jsonschema": "^1.4.1",
    "jsonwebtoken": "^9.0.2",
    "jspdf": "^3.0.0",
    "jspdf-autotable": "^5.0.2",
    "kafkajs": "^2.2.4",
    "mockingoose": "^2.16.2",
    "mongodb": "^6.10.0000",
    "mongoose": "^8.8.1",
    "morgan": "^1.10.0",
    "node-cron": "^3.0.3",
    "nodemailer": "^6.9.16",
    "oracledb": "^6.7.0",
    "p-limit": "^6.1.0",
    "pg": "^8.13.3",
    "pino": "^9.5.0",
    "qs": "^6.13.0",
    "sequelize": "^6.37.5",
    "swagger-ui-express": "^5.0.1",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript-eslint": "^8.14.000",
    "unset-value": "^2.0.1",
    "winston": "^3.17.0"
  }
}
"""
